function u(e){const t=new Uint8Array(e);let r="";for(const o of t)r+=String.fromCharCode(o);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function w(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),r=(4-t.length%4)%4,n=t.padEnd(t.length+r,"="),o=atob(n),i=new ArrayBuffer(o.length),a=new Uint8Array(i);for(let s=0;s<o.length;s++)a[s]=o.charCodeAt(s);return i}function g(){return m.stubThis(globalThis?.PublicKeyCredential!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const m={stubThis:e=>e};function E(e){const{id:t}=e;return{...e,id:w(t),transports:e.transports}}function S(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class d extends Error{constructor({message:t,code:r,cause:n,name:o}){super(t,{cause:n}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=o??n.name,this.code=r}}class v{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const r=new Error("Cancelling existing WebAuthn API call for new one");r.name="AbortError",this.controller.abort(r)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const R=new v,C=["cross-platform","platform"];function O(e){if(e&&!(C.indexOf(e)<0))return e}function T(){if(!g())return h.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return e?.isConditionalMediationAvailable===void 0?h.stubThis(new Promise(t=>t(!1))):h.stubThis(e.isConditionalMediationAvailable())}const h={stubThis:e=>e};function I({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new d({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new d({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const n=globalThis.location.hostname;if(S(n)){if(r.rpId!==n)return new d({message:`The RP ID "${r.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new d({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new d({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function D(e){!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:r=!1,verifyBrowserAutofillInput:n=!0}=e;if(!g())throw new Error("WebAuthn is not supported in this browser");let o;t.allowCredentials?.length!==0&&(o=t.allowCredentials?.map(E));const i={...t,challenge:w(t.challenge),allowCredentials:o},a={};if(r){if(!await T())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&n)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');a.mediation="conditional",i.allowCredentials=[]}a.publicKey=i,a.signal=R.createNewAbortSignal();let s;try{s=await navigator.credentials.get(a)}catch(p){throw I({error:p,options:a})}if(!s)throw new Error("Authentication was not completed");const{id:l,rawId:y,response:c,type:A}=s;let b;return c.userHandle&&(b=u(c.userHandle)),{id:l,rawId:u(y),response:{authenticatorData:u(c.authenticatorData),clientDataJSON:u(c.clientDataJSON),signature:u(c.signature),userHandle:b},type:A,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:O(s.authenticatorAttachment)}}function f(e){const t=new Uint8Array(e);let r="";for(let n=0;n<t.byteLength;n++)r+=String.fromCharCode(t[n]);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function N(e,t){try{console.log("Starting WebAuthn registration for:",{userId:e,email:t});const r=await fetch("/api/webauthn/register/options",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:e,email:t})});if(!r.ok){const l=await r.text();throw new Error("Failed to get registration options: "+l)}const n=await r.json();if(!n||!n.challenge)throw console.error("Invalid options received:",n),new Error("Server did not return valid registration options");console.log("Creating credential with options:",{rpName:n.rp.name,rpID:n.rp.id,userID:t});const o=await navigator.credentials.create({publicKey:{...n,challenge:Uint8Array.from(atob(n.challenge),l=>l.charCodeAt(0)),user:{...n.user,id:Uint8Array.from(atob(n.user.id),l=>l.charCodeAt(0))}}}),i={id:o.id,rawId:f(o.rawId),response:{clientDataJSON:f(o.response.clientDataJSON),attestationObject:f(o.response.attestationObject)},type:o.type};console.log("Sending credential for verification:",{credentialId:i.id,hasRawId:!!i.rawId,hasClientData:!!i.response.clientDataJSON,hasAttestation:!!i.response.attestationObject});const a=await fetch("/api/webauthn/register/verify",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:e,credential:i})});if(!a.ok){const l=await a.text();throw console.error("Verification response error:",l),new Error("Failed to verify registration: "+l)}return{success:(await a.json()).verified}}catch(r){return console.error("WebAuthn registration error:",r),{success:!1,error:r.message}}}async function P(e){try{const t=await fetch("/api/webauthn/login/options",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:e})});if(!t.ok)throw new Error("Failed to get authentication options");const r=await t.json(),n=await D(r),o=await fetch("/api/webauthn/login/verify",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:e,credential:n})});if(!o.ok)throw new Error("Failed to verify authentication");return{success:(await o.json()).verified}}catch(t){return{success:!1,error:t.message}}}async function _(){if(!window.PublicKeyCredential)return!1;try{return await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}catch{return!1}}export{_ as i,P as l,N as r};
//# sourceMappingURL=webAuthnHelper-CFOYufXH.js.map
