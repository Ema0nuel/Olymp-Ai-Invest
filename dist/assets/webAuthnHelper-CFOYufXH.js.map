{"version":3,"file":"webAuthnHelper-CFOYufXH.js","sources":["../../node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js","../../node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js","../../node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js","../../node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js","../../node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js","../../node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js","../../node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js","../../node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js","../../node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js","../../node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js","../../node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js","../../src/script/utils/webAuthnHelper.js"],"sourcesContent":["/**\n * Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various\n * credential response ArrayBuffers to string for sending back to the server as JSON.\n *\n * Helper method to compliment `base64URLStringToBuffer`\n */\nexport function bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n","/**\n * Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a\n * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or\n * excludeCredentials\n *\n * Helper method to compliment `bufferToBase64URLString`\n */\nexport function base64URLStringToBuffer(base64URLString) {\n    // Convert from Base64URL to Base64\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    /**\n     * Pad with '=' until it's a multiple of four\n     * (4 - (85 % 4 = 1) = 3) % 4 = 3 padding\n     * (4 - (86 % 4 = 2) = 2) % 4 = 2 padding\n     * (4 - (87 % 4 = 3) = 1) % 4 = 1 padding\n     * (4 - (88 % 4 = 0) = 4) % 4 = 0 padding\n     */\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    // Convert to a binary string\n    const binary = atob(padded);\n    // Convert binary string to buffer\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n","/**\n * Determine if the browser is capable of Webauthn\n */\nexport function browserSupportsWebAuthn() {\n    return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== undefined &&\n        typeof globalThis.PublicKeyCredential === 'function');\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _browserSupportsWebAuthnInternals = {\n    stubThis: (value) => value,\n};\n","import { base64URLStringToBuffer } from './base64URLStringToBuffer.js';\nexport function toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        /**\n         * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer\n         * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports\n         * are fine to pass to WebAuthn since browsers will recognize the new value.\n         */\n        transports: descriptor.transports,\n    };\n}\n","/**\n * A simple test to determine if a hostname is a properly-formatted domain name\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n */\nexport function isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n","/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */\nexport class WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, { cause });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n","class BaseWebAuthnAbortService {\n    constructor() {\n        Object.defineProperty(this, \"controller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * A service singleton to help ensure that only a single WebAuthn ceremony is active at a time.\n *\n * Users of **@simplewebauthn/browser** shouldn't typically need to use this, but it can help e.g.\n * developers building projects that use client-side routing to better control the behavior of\n * their UX in response to router navigation events.\n */\nexport const WebAuthnAbortService = new BaseWebAuthnAbortService();\n","const attachments = ['cross-platform', 'platform'];\n/**\n * If possible coerce a `string` value into a known `AuthenticatorAttachment`\n */\nexport function toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n","import { browserSupportsWebAuthn } from './browserSupportsWebAuthn.js';\n/**\n * Determine if the browser supports conditional UI, so that WebAuthn credentials can\n * be shown to the user in the browser's typical password autofill popup.\n */\nexport function browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    /**\n     * I don't like the `as unknown` here but there's a `declare var PublicKeyCredential` in\n     * TS' DOM lib that's making it difficult for me to just go `as PublicKeyCredentialFuture` as I\n     * want. I think I'm fine with this for now since it's _supposed_ to be temporary, until TS types\n     * have a chance to catch up.\n     */\n    const globalPublicKeyCredential = globalThis\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential?.isConditionalMediationAvailable === undefined) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n// Make it possible to stub the return value during testing\nexport const _browserSupportsWebAuthnAutofillInternals = {\n    stubThis: (value) => value,\n};\n","import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`\n */\nexport function identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n","import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { browserSupportsWebAuthnAutofill } from '../helpers/browserSupportsWebAuthnAutofill.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyAuthenticationError } from '../helpers/identifyAuthenticationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"login\" via WebAuthn assertion\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`\n * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.\n * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.\n */\nexport async function startAuthentication(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true, } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to avoid passing empty array to avoid blocking retrieval\n    // of public key\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    // Prepare options for `.get()`\n    const getOptions = {};\n    /**\n     * Set up the page to prompt the user to select a credential for authentication via the browser's\n     * input autofill mechanism.\n     */\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        // Check for an <input> with \"webauthn\" in its `autocomplete` attribute\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        // WebAuthn autofill requires at least one valid input\n        if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        // `CredentialMediationRequirement` doesn't know about \"conditional\" yet as of\n        // typescript@4.6.3\n        getOptions.mediation = 'conditional';\n        // Conditional UI requires an empty allow list\n        publicKey.allowCredentials = [];\n    }\n    // Finalize options\n    getOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    getOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete assertion\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(getOptions));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options: getOptions });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    // Convert values to base64 to make it easier to send back to the server\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n","import { startRegistration, startAuthentication } from '@simplewebauthn/browser';\r\n\r\n/**\r\n * Register a new WebAuthn credential for the user.\r\n * @param {string} userId - The user's Supabase user ID.\r\n * @param {string} email - The user's email (for display).\r\n * @returns {Promise<{success: boolean, error?: string}>}\r\n */\r\nfunction bufferToBase64Url(buffer) {\r\n    const bytes = new Uint8Array(buffer);\r\n    let binary = '';\r\n    for (let i = 0; i < bytes.byteLength; i++) {\r\n        binary += String.fromCharCode(bytes[i]);\r\n    }\r\n    return btoa(binary)\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n        .replace(/=+$/, '');\r\n}\r\n\r\nexport async function registerWebAuthn(userId, email) {\r\n    try {\r\n        console.log('Starting WebAuthn registration for:', { userId, email });\r\n\r\n        const optionsRes = await fetch('/api/webauthn/register/options', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ userId, email })\r\n        });\r\n\r\n        if (!optionsRes.ok) {\r\n            const err = await optionsRes.text();\r\n            throw new Error('Failed to get registration options: ' + err);\r\n        }\r\n\r\n        const options = await optionsRes.json();\r\n\r\n        if (!options || !options.challenge) {\r\n            console.error('Invalid options received:', options);\r\n            throw new Error('Server did not return valid registration options');\r\n        }\r\n\r\n        console.log('Creating credential with options:', {\r\n            rpName: options.rp.name,\r\n            rpID: options.rp.id,\r\n            userID: email\r\n        });\r\n\r\n        const credential = await navigator.credentials.create({\r\n            publicKey: {\r\n                ...options,\r\n                challenge: Uint8Array.from(atob(options.challenge), c => c.charCodeAt(0)),\r\n                user: {\r\n                    ...options.user,\r\n                    id: Uint8Array.from(atob(options.user.id), c => c.charCodeAt(0))\r\n                }\r\n            }\r\n        });\r\n\r\n        const payload = {\r\n            id: credential.id,\r\n            rawId: bufferToBase64Url(credential.rawId),\r\n            response: {\r\n                clientDataJSON: bufferToBase64Url(credential.response.clientDataJSON),\r\n                attestationObject: bufferToBase64Url(credential.response.attestationObject)\r\n            },\r\n            type: credential.type\r\n        };\r\n\r\n        console.log('Sending credential for verification:', {\r\n            credentialId: payload.id,\r\n            hasRawId: !!payload.rawId,\r\n            hasClientData: !!payload.response.clientDataJSON,\r\n            hasAttestation: !!payload.response.attestationObject\r\n        });\r\n\r\n        const verifyRes = await fetch('/api/webauthn/register/verify', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({\r\n                userId,\r\n                credential: payload\r\n            })\r\n        });\r\n\r\n        if (!verifyRes.ok) {\r\n            const errorText = await verifyRes.text();\r\n            console.error('Verification response error:', errorText);\r\n            throw new Error('Failed to verify registration: ' + errorText);\r\n        }\r\n\r\n        const verifyData = await verifyRes.json();\r\n        return { success: verifyData.verified };\r\n\r\n    } catch (error) {\r\n        console.error('WebAuthn registration error:', error);\r\n        return {\r\n            success: false,\r\n            error: error.message\r\n        };\r\n    }\r\n}\r\n\r\n// Helper functions for encoding/decoding\r\nfunction bufferToBase64url(buffer) {\r\n    const base64 = btoa(String.fromCharCode(...new Uint8Array(buffer)));\r\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n}\r\n\r\n/**\r\n * Authenticate a user with WebAuthn.\r\n * @param {string} userId - The user's Supabase user ID.\r\n * @returns {Promise<{success: boolean, error?: string}>}\r\n */\r\nexport async function loginWebAuthn(userId) {\r\n    try {\r\n        // 1. Get authentication options from server\r\n        const optionsRes = await fetch('/api/webauthn/login/options', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ userId })\r\n        });\r\n        if (!optionsRes.ok) throw new Error('Failed to get authentication options');\r\n        const options = await optionsRes.json();\r\n\r\n        // 2. Get assertion from browser\r\n        const assertion = await startAuthentication(options);\r\n\r\n        // 3. Send assertion to server for verification\r\n        const verifyRes = await fetch('/api/webauthn/login/verify', {\r\n            method: 'POST',\r\n            headers: { 'Content-Type': 'application/json' },\r\n            body: JSON.stringify({ userId, credential: assertion })\r\n        });\r\n        if (!verifyRes.ok) throw new Error('Failed to verify authentication');\r\n        const verifyData = await verifyRes.json();\r\n\r\n        return { success: verifyData.verified };\r\n    } catch (error) {\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Check if WebAuthn is supported in the current browser.\r\n * @returns {Promise<boolean>}\r\n */\r\nexport async function isWebAuthnAvailable() {\r\n    if (!window.PublicKeyCredential) return false;\r\n    try {\r\n        return await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\r\n    } catch {\r\n        return false;\r\n    }\r\n}"],"names":["bufferToBase64URLString","buffer","bytes","str","charCode","base64URLStringToBuffer","base64URLString","base64","padLength","padded","binary","i","browserSupportsWebAuthn","_browserSupportsWebAuthnInternals","value","toPublicKeyCredentialDescriptor","descriptor","id","isValidDomain","hostname","WebAuthnError","message","code","cause","name","BaseWebAuthnAbortService","abortError","newController","WebAuthnAbortService","attachments","toAuthenticatorAttachment","attachment","browserSupportsWebAuthnAutofill","_browserSupportsWebAuthnAutofillInternals","resolve","globalPublicKeyCredential","identifyAuthenticationError","error","options","publicKey","effectiveDomain","startAuthentication","optionsJSON","useBrowserAutofill","verifyBrowserAutofillInput","allowCredentials","getOptions","credential","err","rawId","response","type","userHandle","bufferToBase64Url","registerWebAuthn","userId","email","optionsRes","c","payload","verifyRes","errorText","loginWebAuthn","assertion","isWebAuthnAvailable"],"mappings":"AAMO,SAASA,EAAwBC,EAAQ,CAC5C,MAAMC,EAAQ,IAAI,WAAWD,CAAM,EACnC,IAAIE,EAAM,GACV,UAAWC,KAAYF,EACnBC,GAAO,OAAO,aAAaC,CAAQ,EAGvC,OADqB,KAAKD,CAAG,EACT,QAAQ,MAAO,GAAG,EAAE,QAAQ,MAAO,GAAG,EAAE,QAAQ,KAAM,EAAE,CAChF,CCPO,SAASE,EAAwBC,EAAiB,CAErD,MAAMC,EAASD,EAAgB,QAAQ,KAAM,GAAG,EAAE,QAAQ,KAAM,GAAG,EAQ7DE,GAAa,EAAKD,EAAO,OAAS,GAAM,EACxCE,EAASF,EAAO,OAAOA,EAAO,OAASC,EAAW,GAAG,EAErDE,EAAS,KAAKD,CAAM,EAEpBR,EAAS,IAAI,YAAYS,EAAO,MAAM,EACtCR,EAAQ,IAAI,WAAWD,CAAM,EACnC,QAASU,EAAI,EAAGA,EAAID,EAAO,OAAQC,IAC/BT,EAAMS,CAAC,EAAID,EAAO,WAAWC,CAAC,EAElC,OAAOV,CACX,CCzBO,SAASW,GAA0B,CACtC,OAAOC,EAAkC,SAAS,YAAY,sBAAwB,QAClF,OAAO,WAAW,qBAAwB,UAAU,CAC5D,CAKO,MAAMA,EAAoC,CAC7C,SAAWC,GAAUA,CACzB,ECZO,SAASC,EAAgCC,EAAY,CACxD,KAAM,CAAE,GAAAC,CAAE,EAAKD,EACf,MAAO,CACH,GAAGA,EACH,GAAIX,EAAwBY,CAAE,EAM9B,WAAYD,EAAW,UAC/B,CACA,CCLO,SAASE,EAAcC,EAAU,CACpC,OAEAA,IAAa,aACT,0CAA0C,KAAKA,CAAQ,CAC/D,CCIO,MAAMC,UAAsB,KAAM,CACrC,YAAY,CAAE,QAAAC,EAAS,KAAAC,EAAM,MAAAC,EAAO,KAAAC,CAAI,EAAK,CAEzC,MAAMH,EAAS,CAAE,MAAAE,EAAO,EACxB,OAAO,eAAe,KAAM,OAAQ,CAChC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,MACnB,CAAS,EACD,KAAK,KAAOC,GAAQD,EAAM,KAC1B,KAAK,KAAOD,CAChB,CACJ,CC9BA,MAAMG,CAAyB,CAC3B,aAAc,CACV,OAAO,eAAe,KAAM,aAAc,CACtC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,MACnB,CAAS,CACL,CACA,sBAAuB,CAEnB,GAAI,KAAK,WAAY,CACjB,MAAMC,EAAa,IAAI,MAAM,mDAAmD,EAChFA,EAAW,KAAO,aAClB,KAAK,WAAW,MAAMA,CAAU,CACpC,CACA,MAAMC,EAAgB,IAAI,gBAC1B,YAAK,WAAaA,EACXA,EAAc,MACzB,CACA,gBAAiB,CACb,GAAI,KAAK,WAAY,CACjB,MAAMD,EAAa,IAAI,MAAM,gDAAgD,EAC7EA,EAAW,KAAO,aAClB,KAAK,WAAW,MAAMA,CAAU,EAChC,KAAK,WAAa,MACtB,CACJ,CACJ,CAQO,MAAME,EAAuB,IAAIH,ECpClCI,EAAc,CAAC,iBAAkB,UAAU,EAI1C,SAASC,EAA0BC,EAAY,CAClD,GAAKA,GAGD,EAAAF,EAAY,QAAQE,CAAU,EAAI,GAGtC,OAAOA,CACX,CCPO,SAASC,GAAkC,CAC9C,GAAI,CAACpB,EAAuB,EACxB,OAAOqB,EAA0C,SAAS,IAAI,QAASC,GAAYA,EAAQ,EAAK,CAAC,CAAC,EAQtG,MAAMC,EAA4B,WAC7B,oBACL,OAAIA,GAA2B,kCAAoC,OACxDF,EAA0C,SAAS,IAAI,QAASC,GAAYA,EAAQ,EAAK,CAAC,CAAC,EAE/FD,EAA0C,SAASE,EAA0B,gCAA+B,CAAE,CACzH,CAEO,MAAMF,EAA4C,CACrD,SAAWnB,GAAUA,CACzB,ECpBO,SAASsB,EAA4B,CAAE,MAAAC,EAAO,QAAAC,GAAY,CAC7D,KAAM,CAAE,UAAAC,CAAS,EAAKD,EACtB,GAAI,CAACC,EACD,MAAM,MAAM,iDAAiD,EAEjE,GAAIF,EAAM,OAAS,cACf,GAAIC,EAAQ,kBAAkB,YAE1B,OAAO,IAAIlB,EAAc,CACrB,QAAS,mDACT,KAAM,yBACN,MAAOiB,CACvB,CAAa,MAGJ,IAAIA,EAAM,OAAS,kBAKpB,OAAO,IAAIjB,EAAc,CACrB,QAASiB,EAAM,QACf,KAAM,uCACN,MAAOA,CACnB,CAAS,EAEA,GAAIA,EAAM,OAAS,gBAAiB,CACrC,MAAMG,EAAkB,WAAW,SAAS,SAC5C,GAAKtB,EAAcsB,CAAe,GAQ7B,GAAID,EAAU,OAASC,EAExB,OAAO,IAAIpB,EAAc,CACrB,QAAS,cAAcmB,EAAU,IAAI,+BACrC,KAAM,sBACN,MAAOF,CACvB,CAAa,MAZD,QAAO,IAAIjB,EAAc,CACrB,QAAS,GAAG,WAAW,SAAS,QAAQ,wBACxC,KAAM,uBACN,MAAOiB,CACvB,CAAa,CAUT,SACSA,EAAM,OAAS,eAGpB,OAAO,IAAIjB,EAAc,CACrB,QAAS,+GACT,KAAM,oCACN,MAAOiB,CACnB,CAAS,EAEL,OAAOA,CACX,CC7CO,eAAeI,EAAoBH,EAAS,CAE3C,CAACA,EAAQ,aAAeA,EAAQ,YAChC,QAAQ,KAAK,8TAA8T,EAE3UA,EAAU,CAAE,YAAaA,CAAO,GAEpC,KAAM,CAAE,YAAAI,EAAa,mBAAAC,EAAqB,GAAO,2BAAAC,EAA6B,EAAI,EAAMN,EACxF,GAAI,CAAC1B,EAAuB,EACxB,MAAM,IAAI,MAAM,2CAA2C,EAI/D,IAAIiC,EACAH,EAAY,kBAAkB,SAAW,IACzCG,EAAmBH,EAAY,kBAAkB,IAAI3B,CAA+B,GAGxF,MAAMwB,EAAY,CACd,GAAGG,EACH,UAAWrC,EAAwBqC,EAAY,SAAS,EACxD,iBAAAG,CACR,EAEUC,EAAa,CAAA,EAKnB,GAAIH,EAAoB,CACpB,GAAI,CAAE,MAAMX,EAA+B,EACvC,MAAM,MAAM,4CAA4C,EAK5D,GAFuB,SAAS,iBAAiB,iCAAiC,EAE/D,OAAS,GAAKY,EAC7B,MAAM,MAAM,mGAAmG,EAInHE,EAAW,UAAY,cAEvBP,EAAU,iBAAmB,CAAA,CACjC,CAEAO,EAAW,UAAYP,EAEvBO,EAAW,OAASlB,EAAqB,qBAAoB,EAE7D,IAAImB,EACJ,GAAI,CACAA,EAAc,MAAM,UAAU,YAAY,IAAID,CAAU,CAC5D,OACOE,EAAK,CACR,MAAMZ,EAA4B,CAAE,MAAOY,EAAK,QAASF,CAAU,CAAE,CACzE,CACA,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,kCAAkC,EAEtD,KAAM,CAAE,GAAA9B,EAAI,MAAAgC,EAAO,SAAAC,EAAU,KAAAC,CAAI,EAAKJ,EACtC,IAAIK,EACJ,OAAIF,EAAS,aACTE,EAAapD,EAAwBkD,EAAS,UAAU,GAGrD,CACH,GAAAjC,EACA,MAAOjB,EAAwBiD,CAAK,EACpC,SAAU,CACN,kBAAmBjD,EAAwBkD,EAAS,iBAAiB,EACrE,eAAgBlD,EAAwBkD,EAAS,cAAc,EAC/D,UAAWlD,EAAwBkD,EAAS,SAAS,EACrD,WAAAE,CACZ,EACQ,KAAAD,EACA,uBAAwBJ,EAAW,0BAAyB,EAC5D,wBAAyBjB,EAA0BiB,EAAW,uBAAuB,CAC7F,CACA,CCtFA,SAASM,EAAkBpD,EAAQ,CAC/B,MAAMC,EAAQ,IAAI,WAAWD,CAAM,EACnC,IAAIS,EAAS,GACb,QAASC,EAAI,EAAGA,EAAIT,EAAM,WAAYS,IAClCD,GAAU,OAAO,aAAaR,EAAMS,CAAC,CAAC,EAE1C,OAAO,KAAKD,CAAM,EACb,QAAQ,MAAO,GAAG,EAClB,QAAQ,MAAO,GAAG,EAClB,QAAQ,MAAO,EAAE,CAC1B,CAEO,eAAe4C,EAAiBC,EAAQC,EAAO,CAClD,GAAI,CACA,QAAQ,IAAI,sCAAuC,CAAE,OAAAD,EAAQ,MAAAC,CAAK,CAAE,EAEpE,MAAMC,EAAa,MAAM,MAAM,iCAAkC,CAC7D,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAkB,EAC7C,KAAM,KAAK,UAAU,CAAE,OAAAF,EAAQ,MAAAC,CAAK,CAAE,CAClD,CAAS,EAED,GAAI,CAACC,EAAW,GAAI,CAChB,MAAMT,EAAM,MAAMS,EAAW,OAC7B,MAAM,IAAI,MAAM,uCAAyCT,CAAG,CAChE,CAEA,MAAMV,EAAU,MAAMmB,EAAW,OAEjC,GAAI,CAACnB,GAAW,CAACA,EAAQ,UACrB,cAAQ,MAAM,4BAA6BA,CAAO,EAC5C,IAAI,MAAM,kDAAkD,EAGtE,QAAQ,IAAI,oCAAqC,CAC7C,OAAQA,EAAQ,GAAG,KACnB,KAAMA,EAAQ,GAAG,GACjB,OAAQkB,CACpB,CAAS,EAED,MAAMT,EAAa,MAAM,UAAU,YAAY,OAAO,CAClD,UAAW,CACP,GAAGT,EACH,UAAW,WAAW,KAAK,KAAKA,EAAQ,SAAS,EAAGoB,GAAKA,EAAE,WAAW,CAAC,CAAC,EACxE,KAAM,CACF,GAAGpB,EAAQ,KACX,GAAI,WAAW,KAAK,KAAKA,EAAQ,KAAK,EAAE,EAAGoB,GAAKA,EAAE,WAAW,CAAC,CAAC,CACnF,CACA,CACA,CAAS,EAEKC,EAAU,CACZ,GAAIZ,EAAW,GACf,MAAOM,EAAkBN,EAAW,KAAK,EACzC,SAAU,CACN,eAAgBM,EAAkBN,EAAW,SAAS,cAAc,EACpE,kBAAmBM,EAAkBN,EAAW,SAAS,iBAAiB,CAC1F,EACY,KAAMA,EAAW,IAC7B,EAEQ,QAAQ,IAAI,uCAAwC,CAChD,aAAcY,EAAQ,GACtB,SAAU,CAAC,CAACA,EAAQ,MACpB,cAAe,CAAC,CAACA,EAAQ,SAAS,eAClC,eAAgB,CAAC,CAACA,EAAQ,SAAS,iBAC/C,CAAS,EAED,MAAMC,EAAY,MAAM,MAAM,gCAAiC,CAC3D,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAkB,EAC7C,KAAM,KAAK,UAAU,CACjB,OAAAL,EACA,WAAYI,CAC5B,CAAa,CACb,CAAS,EAED,GAAI,CAACC,EAAU,GAAI,CACf,MAAMC,EAAY,MAAMD,EAAU,OAClC,cAAQ,MAAM,+BAAgCC,CAAS,EACjD,IAAI,MAAM,kCAAoCA,CAAS,CACjE,CAGA,MAAO,CAAE,SADU,MAAMD,EAAU,QACN,SAEjC,OAASvB,EAAO,CACZ,eAAQ,MAAM,+BAAgCA,CAAK,EAC5C,CACH,QAAS,GACT,MAAOA,EAAM,OACzB,CACI,CACJ,CAaO,eAAeyB,EAAcP,EAAQ,CACxC,GAAI,CAEA,MAAME,EAAa,MAAM,MAAM,8BAA+B,CAC1D,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAkB,EAC7C,KAAM,KAAK,UAAU,CAAE,OAAAF,CAAM,CAAE,CAC3C,CAAS,EACD,GAAI,CAACE,EAAW,GAAI,MAAM,IAAI,MAAM,sCAAsC,EAC1E,MAAMnB,EAAU,MAAMmB,EAAW,OAG3BM,EAAY,MAAMtB,EAAoBH,CAAO,EAG7CsB,EAAY,MAAM,MAAM,6BAA8B,CACxD,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAkB,EAC7C,KAAM,KAAK,UAAU,CAAE,OAAAL,EAAQ,WAAYQ,EAAW,CAClE,CAAS,EACD,GAAI,CAACH,EAAU,GAAI,MAAM,IAAI,MAAM,iCAAiC,EAGpE,MAAO,CAAE,SAFU,MAAMA,EAAU,QAEN,SACjC,OAASvB,EAAO,CACZ,MAAO,CAAE,QAAS,GAAO,MAAOA,EAAM,OAAO,CACjD,CACJ,CAMO,eAAe2B,GAAsB,CACxC,GAAI,CAAC,OAAO,oBAAqB,MAAO,GACxC,GAAI,CACA,OAAO,MAAM,OAAO,oBAAoB,+CAC5C,MAAQ,CACJ,MAAO,EACX,CACJ","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}